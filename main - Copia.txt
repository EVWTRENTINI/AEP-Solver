#include "raylib.h"
#include "raymath.h"

#include "imgui.h"
#include "rlImGui.h"
#include "imgui_impl_raylib.h"
#include "rlImGuiColors.h"

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <sstream>
#include <limits>

// Cereal
#include <fstream>
#include <cereal/cereal.hpp>
#include <cereal/types/memory.hpp>
#include <cereal/types/vector.hpp>
#include <cereal/archives/json.hpp>
template <class Archive>
void serialize(Archive & archive, Vector2 & v) {
    archive(
		cereal::make_nvp("x", v.x),
		cereal::make_nvp("y", v.y));
}
template <class Archive>
void serialize(Archive & archive, Camera2D & camera) {
    archive(
        cereal::make_nvp("offset", camera.offset),
        cereal::make_nvp("target", camera.target),
        cereal::make_nvp("rotation", camera.rotation),
        cereal::make_nvp("zoom", camera.zoom));
}

// My includes
#include "globals.h"
#include "beam.h"
#include "node.h"


int mainMenuSize = 24;
int topMenuSize = 120;
int leftMenuSize = 100;
int rightMenuSize = 200;
int bottomMenuSize = 19;
int topPadding = mainMenuSize + topMenuSize;


bool Quit = false;

bool ImGuiDemoOpen = false;

class DocumentWindow
{
public:
	bool Open = false;


	virtual void Setup() = 0;
	virtual void Shutdown() = 0;
	virtual void Show() = 0;
	virtual void Update() = 0;

	bool Focused = false;

	Rectangle ContentRect = { 0 };
};


enum class ToolMode
	{
		None,
		NodeAdd,
		NodeRem,
		NodeMov,
		BeamAdd,
		BeamRem,
		SupportNone,
		SupportLx,
		SupportLy,
		SupportLxy,
		SupportTv,
		SupportTh,
	};

ToolMode toolMode = ToolMode::None;

class TopMenuWindow : public DocumentWindow
{
public:
	
	
	
	
	void Setup() override
	{
		
	}

	void Shutdown() override
	{

	}

	void Show() override
	{
		float cursorPosX;	
		const char* titulo;
		float padding = 3.0f;
		int Nbuttons;
		int buttonWidth;
		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(padding, padding));
		ImGui::SetNextWindowPos(ImVec2(0, mainMenuSize)); 
        ImGui::SetNextWindowSize(ImVec2(GetScreenWidth(), topMenuSize));
		
		    if (ImGui::Begin("Top Menu", &Open, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove))
    		{
				ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.0f, 0.0f, 0.0f, 0.f)); // Borda transparente
				ImVec2 currentSpacing = ImVec2(5, 5);
				ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, currentSpacing);
    		    if (ImGui::BeginTabBar("TopMenuTabBar"))
    		    {		
    		        if (ImGui::BeginTabItem("Editar"))
    		        {
						titulo = "Nós";
						Nbuttons = 3;
						buttonWidth = 70;
    		            ImGui::BeginChild(titulo, ImVec2(padding * 2 + Nbuttons * buttonWidth + (Nbuttons - 1) * currentSpacing.x, 0), true, ImGuiWindowFlags_NoScrollbar);
    		            	if (ImGui::Button("Adicionar", ImVec2(buttonWidth, ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::NodeAdd;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Remover", ImVec2(buttonWidth, ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::NodeRem;}
    		            	ImGui::SameLine();
							if (ImGui::Button("Mover", ImVec2(buttonWidth, ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::NodeMov;}
							cursorPosX = (ImGui::GetContentRegionAvail().x - ImGui::CalcTextSize(titulo).x) / 2;
                			ImGui::SetCursorPosX(cursorPosX);
                			ImGui::Text(titulo);
    		            ImGui::EndChild();

    		            ImGui::SameLine(); 
						float line_height = ImGui::GetItemRectSize().y;
						ImVec2 p = ImGui::GetCursorScreenPos();
						ImDrawList* draw_list = ImGui::GetWindowDrawList();
						draw_list->AddLine(ImVec2(p.x -currentSpacing.x/2 -1, p.y), ImVec2(p.x-currentSpacing.x/2 -1, p.y + line_height), IM_COL32(150, 150, 150, 255));

						ImGui::SameLine();

    		            titulo = "Barras";
						Nbuttons = 2;
						buttonWidth = 70;
    		            ImGui::BeginChild(titulo, ImVec2(padding * 2 + Nbuttons * buttonWidth + (Nbuttons - 1) * currentSpacing.x, 0), true, ImGuiWindowFlags_NoScrollbar);
    		            	if (ImGui::Button("Adicionar", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::BeamAdd;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Remover", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::BeamRem;}
							cursorPosX = (ImGui::GetContentRegionAvail().x - ImGui::CalcTextSize(titulo).x) / 2;
                			ImGui::SetCursorPosX(cursorPosX);
                			ImGui::Text(titulo);
    		            ImGui::EndChild(); 

    		            ImGui::SameLine(); 
						line_height = ImGui::GetItemRectSize().y;
						p = ImGui::GetCursorScreenPos();
						draw_list = ImGui::GetWindowDrawList();
						draw_list->AddLine(ImVec2(p.x -currentSpacing.x/2 -1, p.y), ImVec2(p.x-currentSpacing.x/2 -1, p.y + line_height), IM_COL32(150, 150, 150, 255));
						ImGui::SameLine();

						titulo = "Apoios";
						Nbuttons = 6;
						buttonWidth = 90;
    		            ImGui::BeginChild(titulo, ImVec2(padding * 2 + Nbuttons * buttonWidth + (Nbuttons - 1) * currentSpacing.x, 0), true, ImGuiWindowFlags_NoScrollbar);
							if (ImGui::Button("Nenhum", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportNone;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Translação x", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportLx;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Translação y", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportLy;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Translação x-y", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportLxy;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Engaste ver", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportTv;}
							ImGui::SameLine();
    		            	if (ImGui::Button("Engaste hor", ImVec2(buttonWidth,  ImGui::GetContentRegionAvail().y - ImGui::CalcTextSize(titulo).y - currentSpacing.y))){
								toolMode = ToolMode::SupportTh;}

							cursorPosX = (ImGui::GetContentRegionAvail().x - ImGui::CalcTextSize(titulo).x) / 2;
                			ImGui::SetCursorPosX(cursorPosX);
                			ImGui::Text(titulo);
    		            ImGui::EndChild(); 

    		            ImGui::EndTabItem();
    		        }
					if (ImGui::BeginTabItem("Carregamento"))
    		        {
    		            ImGui::Text("Funcionalidades serão adicionadas aqui.");
    		            ImGui::EndTabItem();
    		        }


    		        if (ImGui::BeginTabItem("Analisar"))
    		        {
    		            ImGui::Text("Funcionalidades serão adicionadas aqui.");
    		            ImGui::EndTabItem();
    		        }

					ImGui::PopStyleVar(2);
					ImGui::PopStyleColor(1);
    		        ImGui::EndTabBar();
					
    		    }
    		}
		ImGui::End();
	}

	void Update() override
	{
		if (!Open)
			return;
		if (IsKeyDown(KEY_ESCAPE))
			toolMode = ToolMode::None;
		//std::cout << static_cast<int>(CurrentToolMode) << std::endl;
	}
 
	Texture2D GridTexture = { 0 };
};

TopMenuWindow topMenu;


class ToolsMenuWindow : public DocumentWindow
{
public:
	enum class ToolMode
	{
		None,
		No,
		Barra,
	};
	ToolMode CurrentToolMode = ToolMode::None;

	void Setup() override
	{
		
	}

	void Shutdown() override
	{

	}

	void Show() override
	{
		float windowHeight = GetScreenHeight() - topPadding;

		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
		ImGui::SetNextWindowPos(ImVec2(0, topPadding)); 
        ImGui::SetNextWindowSize(ImVec2(leftMenuSize, windowHeight));
		
		if (ImGui::Begin("Ferramentas", &Open, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove))
		{

			Focused = ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows);
			// Desenha oq quiser
			if (windowHeight > 1){
				if (ImGui::BeginChild("Toolbar", ImVec2(ImGui::GetContentRegionAvail().x, windowHeight), ImGuiWindowFlags_NoScrollbar))
				{
					ImGui::SetCursorPosX(2);
					ImGui::SetCursorPosY(3);
					switch (CurrentToolMode)
					{
						case ToolMode::None:
							ImGui::TextUnformatted("Nenhuma");
							break;
						case ToolMode::No:
							ImGui::TextUnformatted("Editar nós");
							break;
						case ToolMode::Barra:
							ImGui::TextUnformatted("Editar barras");
							break;
						default:
							break;
					}

					if (ImGui::Button("Nenhuma", ImVec2(-1, 0)))
					{
						CurrentToolMode = ToolMode::None;
					}

					if (ImGui::Button("Nó", ImVec2(-1, 0)))
					{
						CurrentToolMode = ToolMode::No;
					}

					if (ImGui::Button("Barra", ImVec2(-1, 0)))
					{
						CurrentToolMode = ToolMode::Barra;
					}


					ImGui::EndChild();
				}
			}
		}
		ImGui::End();
		ImGui::PopStyleVar();
	}

	void Update() override
	{
		if (!Open)
			return;
	}
 
	Texture2D GridTexture = { 0 };
};

ToolsMenuWindow toolsMenu;


float EaseInOutQuad(float t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}


Vector2 GetMouseWorldPosition2D(const Camera2D& camera) {
    Vector2 mousePos = GetMousePosition();
    return GetScreenToWorld2D(mousePos, camera);
}




class NodeManager {
public:
    std::vector<std::shared_ptr<Node>> nodes;
	bool drawNodeSelector = false;

    void AddNode(Vector2 position) {
        auto it = std::find_if(nodes.begin(), nodes.end(), [&](const std::shared_ptr<Node>& node) {
            return node->position.x == position.x && node->position.y == position.y;
        });

        // Só adicione o nó se não encontrar um nó na mesma posição
        if (it == nodes.end()) {
            nodes.emplace_back(std::make_shared<Node>(position));
        }
    }

    void RemoveNode(const std::vector<std::shared_ptr<Node>>& nodesToRemove) {
        for (auto& node : nodesToRemove) {
            nodes.erase(std::remove(nodes.begin(), nodes.end(), node), nodes.end());
        }
    }

    void DrawNodes(Camera2D camera) const {
        for (const auto& node : nodes) {
            node->Draw(camera);
        }
    }


	std::shared_ptr<Node> FindClosestNode(Vector2 mouseWorldPosition, Camera2D camera){
		float minDist = std::numeric_limits<float>::max();
			
		std::shared_ptr<Node> closestNode = nullptr;

		for (auto& node : nodes) {
	        if (node->IsNearby(mouseWorldPosition, raioNo, camera.zoom)) {
	            float dist = Vector2DistanceSqr(node->position, mouseWorldPosition);
	            if (dist < minDist) {
	                minDist = dist;
	                closestNode = node;
	            }
	        }
	    }

		return closestNode;
	}
	template <class Archive>
    void serialize(Archive& ar) {
        ar(cereal::make_nvp("nodes", nodes));
    }
};

class CameraController {
public:
	Camera2D camera;
	float bZoom;
	float r = .0000001f;

	CameraController(){
		camera.offset = {GetScreenWidth() / 2.0f, GetScreenHeight() / 2.0f};
        camera.target = {0.0f, 0.0f};
        camera.rotation = 0.0f;
        camera.zoom = 20.0f;

		bZoom = camera.zoom;
	}

	void UpdateCamera(){
		// Translate based on mouse right click
		if (IsMouseButtonDown(MOUSE_BUTTON_RIGHT))
		{
			Vector2 delta = GetMouseDelta();
			delta = Vector2Scale(delta, -1.0f / camera.zoom);
			camera.target = Vector2Add(camera.target, delta);
		}
		if (IsWindowResized())
		{
			camera.offset = {GetScreenWidth() / 2.0f, GetScreenHeight() / 2.0f};
		}
		// Zoom based on mouse wheel
		float wheel = GetMouseWheelMove();
		if (wheel != 0)	{
			// Get the world point that is under the mouse
			Vector2 mouseWorldPos = GetScreenToWorld2D(GetMousePosition(), camera);

			// Set the offset to where the mouse is
			camera.offset = GetMousePosition();

			// Set the target to match, so that the camera maps the world space point
			// under the cursor to the screen space point under the cursor at any zoom
			camera.target = mouseWorldPos;

			// Zoom increment
			float scaleFactor = 1.0f + (0.25f * fabsf(wheel));
			if (wheel < 0)
				scaleFactor = 1.0f / scaleFactor;
			bZoom = Clamp(bZoom * scaleFactor, 1.0f, 100000.0f);
			
		}
		camera.zoom = (camera.zoom-bZoom)*pow(r,GetFrameTime())+bZoom;
	}
	template <class Archive>
    void serialize(Archive& ar) {
        ar(
            cereal::make_nvp("camera", camera),
            cereal::make_nvp("bZoom", bZoom)
        );
    }

};

void drawSelector(Vector2 center, Camera2D camera, Color color){
	float cursorSize = 25;
	float cursorGap = 7;
	float cursorWidth = 3;
	
	Vector2 v1 = {(center.x - (cursorSize / 2) / camera.zoom), (center.y + (cursorSize / 2) / camera.zoom)};
	Vector2 v2 = {(center.x - (cursorGap / 2) / camera.zoom), (center.y + (cursorSize / 2) / camera.zoom)};
	Vector2 v3 = {(center.x - (cursorGap / 2) / camera.zoom), (center.y + (cursorSize / 2 - cursorWidth) / camera.zoom)};
	Vector2 v4 = {(center.x - (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y + (cursorSize / 2 - cursorWidth) / camera.zoom)};
	Vector2 v5 = {(center.x - (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y + (cursorGap / 2) / camera.zoom)};
	Vector2 v6 = {(center.x - (cursorSize / 2) / camera.zoom), (center.y + (cursorGap / 2) / camera.zoom)};
	
	BeginMode2D(camera);
	DrawTriangle(v1, v2, v3, color); 
	DrawTriangle(v1, v3, v4, color); 
	DrawTriangle(v1, v4, v5, color); 
	DrawTriangle(v1, v5, v6, color); 
	EndMode2D();

	v1 = {(center.x + (cursorSize / 2) / camera.zoom), (center.y + (cursorSize / 2) / camera.zoom)};
	v2 = {(center.x + (cursorGap / 2) / camera.zoom), (center.y + (cursorSize / 2) / camera.zoom)};
	v3 = {(center.x + (cursorGap / 2) / camera.zoom), (center.y + (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v4 = {(center.x + (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y + (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v5 = {(center.x + (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y + (cursorGap / 2) / camera.zoom)};
	v6 = {(center.x + (cursorSize / 2) / camera.zoom), (center.y + (cursorGap / 2) / camera.zoom)};
	
	BeginMode2D(camera);
	DrawTriangle(v3, v2, v1, color); 
	DrawTriangle(v4, v3, v1, color); 
	DrawTriangle(v5, v4, v1, color); 
	DrawTriangle(v6, v5, v1, color); 
	EndMode2D();

	v1 = {(center.x - (cursorSize / 2) / camera.zoom), (center.y - (cursorSize / 2) / camera.zoom)};
	v2 = {(center.x - (cursorGap / 2) / camera.zoom), (center.y - (cursorSize / 2) / camera.zoom)};
	v3 = {(center.x - (cursorGap / 2) / camera.zoom), (center.y - (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v4 = {(center.x - (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y - (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v5 = {(center.x - (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y - (cursorGap / 2) / camera.zoom)};
	v6 = {(center.x - (cursorSize / 2) / camera.zoom), (center.y - (cursorGap / 2) / camera.zoom)};
	
	BeginMode2D(camera);
	DrawTriangle(v3, v2, v1, color); 
	DrawTriangle(v4, v3, v1, color); 
	DrawTriangle(v5, v4, v1, color); 
	DrawTriangle(v6, v5, v1, color); 
	EndMode2D();

	v1 = {(center.x + (cursorSize / 2) / camera.zoom), (center.y - (cursorSize / 2) / camera.zoom)};
	v2 = {(center.x + (cursorGap / 2) / camera.zoom), (center.y - (cursorSize / 2) / camera.zoom)};
	v3 = {(center.x + (cursorGap / 2) / camera.zoom), (center.y - (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v4 = {(center.x + (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y - (cursorSize / 2 - cursorWidth) / camera.zoom)};
	v5 = {(center.x + (cursorSize / 2 - cursorWidth) / camera.zoom), (center.y - (cursorGap / 2) / camera.zoom)};
	v6 = {(center.x + (cursorSize / 2) / camera.zoom), (center.y - (cursorGap / 2) / camera.zoom)};
	
	BeginMode2D(camera);
	DrawTriangle(v1, v2, v3, color); 
	DrawTriangle(v1, v3, v4, color); 
	DrawTriangle(v1, v4, v5, color); 
	DrawTriangle(v1, v5, v6, color); 
	EndMode2D();

};

struct SelectorToDraw {
    Vector2 center;  // Posição central do elemento visual
    Camera2D camera; // Câmera associada ao elemento visual
    Color color;     // Cor do elemento visual

    // Construtor padrão
    SelectorToDraw() = default;

    // Construtor com parâmetros
    SelectorToDraw(Vector2 c, Camera2D cam, Color col) : center(c), camera(cam), color(col) {}

};

class NodeGuide{
public:
	Vector2 position;
	double creationTime;
    bool activeX;
    bool activeY;

    NodeGuide(Vector2 pos, double time) : position(pos), creationTime(time), activeX(false), activeY(false) {}


};

class NodeGuideManager{
public:
int lastNodeSelected = -1;
double hoverStartTime = 0.0;
bool alreadyCreated = false;
float timeToCreate = 1;
bool drawNodeGuideSelector = false;
bool drawDistanceSelector = false;
SelectorToDraw selectorToDraw;
NodeGuide* closestGuideX = nullptr;
NodeGuide* closestGuideY = nullptr;
std::vector<SelectorToDraw> selectors;


std::vector<NodeGuide> guides;

void AddGuideLine(Vector2 position)
{
	std::vector<NodeGuide>::iterator it = std::find_if(guides.begin(), guides.end(), [&position](const NodeGuide &guide)
													   { return guide.position.x == position.x && guide.position.y == position.y; });
	if (it != guides.end()){
		guides.erase(it);
	} else {
			guides.emplace_back(position, GetTime());
	}
}

void UpdateGuides(const std::vector<std::shared_ptr<Node>> *nodes, Vector2 mousePosition, Camera2D camera)
{
	if (IsKeyPressed(KEY_ESCAPE))	{
		guides.clear();
	}

	for (NodeGuide &guide : guides) {

        // Verifica a distancia vertical para a linha horizontal
        if (std::abs(mousePosition.y - guide.position.y) <= 10 / camera.zoom) {
            guide.activeY = true;
        } else {
            guide.activeY = false;
        }

        // Verifica a distancia horizontal para a linha vertical
        if (std::abs(mousePosition.x - guide.position.x) <= 10 / camera.zoom) {
            guide.activeX = true;
        } else {
            guide.activeX = false;
        }
    }
	drawNodeGuideSelector = false;
	if (nodes)	{
		for (const std::shared_ptr<Node>& node : *nodes)
		{
			if (node->IsNearby(mousePosition, raioNo, camera.zoom))	{
				if (lastNodeSelected != node->id){
					lastNodeSelected = node->id;
					hoverStartTime = GetTime();
				}
				else if ((GetTime() - hoverStartTime) >= timeToCreate){
					if (!alreadyCreated) {
					alreadyCreated = true;
					AddGuideLine(node->position);
					}
				}else{
					float alphaValue = ((GetTime() - hoverStartTime) / timeToCreate*2) * 255.0f;
					int alphaInt = static_cast<int>(round(alphaValue));
					alphaInt = Clamp(alphaInt, 0, 255);
					drawNodeGuideSelector = true;
					selectorToDraw.center = node->position;
					selectorToDraw.camera = camera;
					selectorToDraw.color = Color{255, 255, 0, static_cast<unsigned char>(alphaInt)};
				}
			}
			else
			{
				if (lastNodeSelected == node->id){
					lastNodeSelected = -1;
					hoverStartTime = 0.0; // Reseta o temporizador
					alreadyCreated = false;
				}
			}
		}
	}


}

void FindClosestGuides(Vector2 mousePosition, Camera2D camera){
	float minDistX = std::numeric_limits<float>::max();
	float minDistY = std::numeric_limits<float>::max();

	closestGuideX = nullptr;
	closestGuideY = nullptr;

	for (auto& guide : guides) {
        if (guide.activeX) {
            float distX = std::abs(guide.position.x - mousePosition.x);
            if (distX < minDistX) {
                minDistX = distX;
                closestGuideX = &guide;
            }
        }

        if (guide.activeY) {
            float distY = std::abs(guide.position.y - mousePosition.y);
            if (distY < minDistY) {
                minDistY = distY;
                closestGuideY = &guide;
            }
        }
    }

	if (closestGuideX){
		drawDistanceSelector = true;
		selectors.emplace_back(closestGuideX->position, camera, Color{255, 255, 0, 255});
	}
	if (closestGuideY){
		drawDistanceSelector = true;
		selectors.emplace_back(closestGuideY->position, camera, Color{255, 255, 0, 255});
	}
	if (closestGuideX && closestGuideY){
		drawDistanceSelector = false;
		selectors.clear();
	}
	

}

void DrawGuides(Camera2D camera)
{
	BeginMode2D(camera);
	double currentTime = GetTime();
	for (const NodeGuide &guide : guides)
	{
		double elapsedTime = currentTime - guide.creationTime;
		float alpha = elapsedTime / 0.2f;
		alpha = Clamp(alpha, 0.0f, 1.0f);
		alpha = EaseInOutQuad(alpha);
        unsigned char alphaIntX = static_cast<unsigned char>((guide.activeX ? 1.0f : 0.2f) * alpha * 255);
        unsigned char alphaIntY = static_cast<unsigned char>((guide.activeY ? 1.0f : 0.2f) * alpha * 255);

        Color guideColorX = {255, 127, 39, alphaIntX};
        Color guideColorY = {255, 127, 39, alphaIntY};

		float thickness = 10.0f + (2.0f - 10.0f) * alpha;

		Vector2 worldTopLeftMost = GetScreenToWorld2D(Vector2{0, 0}, camera);
		Vector2 worldBottomRightMost = GetScreenToWorld2D(Vector2{static_cast<float>(GetScreenWidth()), static_cast<float>(GetScreenHeight())}, camera);

        float left = guide.position.x + alpha * (worldTopLeftMost.x - guide.position.x);
        float right = guide.position.x + alpha * (worldBottomRightMost.x - guide.position.x);
        float top = guide.position.y + alpha * (worldTopLeftMost.y - guide.position.y);
        float bottom = guide.position.y + alpha * (worldBottomRightMost.y - guide.position.y);

        DrawLineEx(Vector2{left, guide.position.y}, Vector2{right, guide.position.y}, thickness / camera.zoom, guideColorY);
        DrawLineEx(Vector2{guide.position.x, top}, Vector2{guide.position.x, bottom}, thickness / camera.zoom, guideColorX);
	}
	EndMode2D();
}
};

float CalculateSpacing(float baseSpacing, float zoomLevel) {
    float rawSpacing = baseSpacing / zoomLevel;
    float exponent = floor(log10(rawSpacing));
    float normalizedSpacing = pow(10, exponent);

    // Ajuste para espaçamentos menores que 1
    if (rawSpacing / normalizedSpacing < 1.0) {
        normalizedSpacing /= 10;
    }

    return normalizedSpacing;
}

void DrawBackgroundGrid(Camera2D camera) {
    // Calcule o espaçamento baseado no zoom da camera
    float baseSpacing = 100.0f; // Espaçamento base
    float zoomLevel = camera.zoom;
    float spacing = CalculateSpacing(baseSpacing, zoomLevel);

    // Calcule os limites da tela em coordenadas do mundo
    Vector2 worldTopLeft = GetScreenToWorld2D(Vector2{0, 0}, camera);
    Vector2 worldBottomRight = GetScreenToWorld2D(Vector2{(float)GetScreenWidth(), (float)GetScreenHeight()}, camera);

    // Desenhar a camada secundária (linhas mais fracas)
    float secondarySpacing = spacing;
    Color secondaryColor = Color{ 0, 0, 0, 25};

    float startX = worldTopLeft.x - fmod(worldTopLeft.x, secondarySpacing);
    float startY = worldTopLeft.y - fmod(worldTopLeft.y, secondarySpacing);
	BeginMode2D(camera);
    for (float x = startX; x < worldBottomRight.x; x += secondarySpacing) {
        // Desenhe a linha secundária apenas se não estiver em uma linha primária
        if (fmod(x, spacing * 5) != 0) {
            DrawLineEx(Vector2{x, worldTopLeft.y}, Vector2{x, worldBottomRight.y}, 1.0f / camera.zoom, secondaryColor);
        }
    }

    for (float y = startY; y < worldBottomRight.y; y += secondarySpacing) {
        // Desenhe a linha secundária apenas se não estiver em uma linha primária
        if (fmod(y, spacing * 5) != 0) {
            DrawLineEx(Vector2{worldTopLeft.x, y}, Vector2{worldBottomRight.x, y}, 1.0f / camera.zoom, secondaryColor);
        }
    }

    // Desenhar a camada primária (linhas mais fortes)
    float primarySpacing = spacing * 5.0f;
    Color primaryColor = Color{ 0, 0, 0, 50};

    startX = worldTopLeft.x - fmod(worldTopLeft.x, primarySpacing);
    startY = worldTopLeft.y - fmod(worldTopLeft.y, primarySpacing);

    for (float x = startX; x < worldBottomRight.x; x += primarySpacing) {
        DrawLineEx(Vector2{x, worldTopLeft.y}, Vector2{x, worldBottomRight.y}, 2.0f / camera.zoom, primaryColor);
    }

    for (float y = startY; y < worldBottomRight.y; y += primarySpacing) {
        DrawLineEx(Vector2{worldTopLeft.x, y}, Vector2{worldBottomRight.x, y}, 2.0f / camera.zoom, primaryColor);
    }

    EndMode2D();
}

Vector2 RoundPositionToGrid(Vector2 position, float spacing) {
    position.x = round(position.x / spacing) * spacing;
    position.y = round(position.y / spacing) * spacing;
    return position;
}

bool IsMouseOverRec(Vector2 mousePosition, int xi, int xf, int yi, int yf){
	return (mousePosition.x > xi && mousePosition.x < xf &&
			mousePosition.y > yi && mousePosition.y < yf);
}

class DistanceInputWindow{
public:
bool showDistanceWindow = false;
char distanceInput[30] = "";
Vector2 screenPosition;
Vector2 clickWorldPosition;
Vector2 nodeWorldPosition;
bool isX;
bool firstTimeOpened = true;
float distance;
bool createNode = false;


void draw(){
	if (showDistanceWindow){
		


            ImGui::SetNextWindowPos(ImVec2(screenPosition.x - 175/2, screenPosition.y - 65));
            ImGui::Begin("Criar nó", &showDistanceWindow, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoCollapse);
            ImGui::Text("Distância do nó selecionado:");
			if (firstTimeOpened) {
    			ImGui::SetKeyboardFocusHere();
    			firstTimeOpened = false;
				if (isX) {
                	snprintf(distanceInput, sizeof(clickWorldPosition), "%.3f", std::abs(clickWorldPosition.y - nodeWorldPosition.y));
           		} else {
                snprintf(distanceInput, sizeof(distanceInput), "%.3f", std::abs(clickWorldPosition.x - nodeWorldPosition.x));
            	}
			}
			ImGui::PushItemWidth(175);
            ImGui::InputText("##distance", distanceInput, IM_ARRAYSIZE(distanceInput));
			ImGui::PopItemWidth(); // Restaura a largura padrão para os próximos itens
			float buttonWidth = ImGui::GetContentRegionAvail().x / 2 - ImGui::GetStyle().ItemSpacing.x / 2;
            if (ImGui::Button("Confirmar", ImVec2(buttonWidth, 0)) || ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter)) {
				std::cout << "Botão Confirmar pressionado!" << std::endl;
            	distance = atof(distanceInput);
				if (isX) {
					if (nodeWorldPosition.y - clickWorldPosition.y > 0){
						distance = -distance;
					}
				}else{
					if (nodeWorldPosition.x - clickWorldPosition.x > 0){
						distance = -distance;
					}
				}

				createNode = true;
                showDistanceWindow = false;
				firstTimeOpened = true;
            }
			ImGui::SameLine();
            if (ImGui::Button("Cancelar", ImVec2(buttonWidth, 0)) || ImGui::IsKeyPressed(ImGuiKey_Escape)) {
                showDistanceWindow = false;
				firstTimeOpened = true;
            }
            ImGui::End();
	}else {
        firstTimeOpened = true;
    }
	
	}

};

class EditorWindow : public DocumentWindow
{
public:

bool showGrid = true;
float baseSpacing = 100.0f;
NodeGuideManager nodeGuideManager;
CameraController cameraController;
NodeManager nodeManager;
Vector2 worldPosition;
Vector2 mousePosition;
std::string positionText;
DistanceInputWindow distanceInputWindow;
std::shared_ptr<Node> closestNode;
Vector2 worldGridPosition;
BeamManager beamManager;
std::shared_ptr<Node> beamStart = nullptr;
std::shared_ptr<Node> beamEnd = nullptr;
bool drawCursorOnClosestNode = false;
std::vector<std::shared_ptr<Node>> nodesToRemove;




	void Setup() override
	{

	}

	void Shutdown() override
	{

	}

	void Show() override
	{
		beamManager.DrawShadows(cameraController.camera);
		if (showGrid) {
            DrawBackgroundGrid(cameraController.camera);
        }
		nodeGuideManager.DrawGuides(cameraController.camera);
		beamManager.Draw(cameraController.camera);
		nodeManager.DrawNodes(cameraController.camera);
		if (nodeGuideManager.drawNodeGuideSelector){
			drawSelector(nodeGuideManager.selectorToDraw.center, nodeGuideManager.selectorToDraw.camera, nodeGuideManager.selectorToDraw.color);
		}
		if (nodeGuideManager.drawDistanceSelector){
			for (const auto& selector : nodeGuideManager.selectors) {
            	drawSelector(selector.center, selector.camera, selector.color);
			}
		}


		if (drawCursorOnClosestNode){
			if (closestNode){
				drawSelector(closestNode->position, cameraController.camera, Color{255, 255, 0, 255});
			}
		}

		if (beamStart){
			drawSelector(beamStart->position, cameraController.camera, Color{255, 255, 0, 255});
		}
		
		
    	
    	int textWidth = MeasureText(positionText.c_str(), 20);
    	DrawText(positionText.c_str(), GetScreenWidth() - textWidth - 10, GetScreenHeight() - 30, 20, WHITE);
		

		
	}

	void Update() override
	{
		mousePosition = GetMousePosition();
		worldPosition = GetScreenToWorld2D(mousePosition, cameraController.camera);

		drawCursorOnClosestNode = false;

		if (!Open || !IsMouseOverRec(mousePosition, leftMenuSize, GetScreenWidth() - rightMenuSize, topPadding, GetScreenHeight() - bottomMenuSize))
			return;

		cameraController.UpdateCamera();

		if (IsKeyPressed(KEY_G)) {
       		showGrid = !showGrid;
    	}

		worldGridPosition = worldPosition = GetScreenToWorld2D(mousePosition, cameraController.camera);
		if (showGrid)
			worldGridPosition = RoundPositionToGrid(worldPosition, CalculateSpacing(baseSpacing, cameraController.camera.zoom));
		
		
		if (distanceInputWindow.createNode){
			distanceInputWindow.createNode = false;

			if (distanceInputWindow.isX){ // Se for distancia em x
				nodeManager.AddNode(Vector2{distanceInputWindow.nodeWorldPosition.x, distanceInputWindow.nodeWorldPosition.y + distanceInputWindow.distance});
			}else{ // Se for distancia em y
				nodeManager.AddNode(Vector2{distanceInputWindow.nodeWorldPosition.x + distanceInputWindow.distance, distanceInputWindow.nodeWorldPosition.y});
			}
			
		}

		nodeGuideManager.drawDistanceSelector = false;
		nodeGuideManager.selectors.clear();

		switch (toolMode) {
		    case ToolMode::None:

		        break;

			case ToolMode::NodeAdd:
				if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
					nodeGuideManager.FindClosestGuides(GetScreenToWorld2D(mousePosition, cameraController.camera), cameraController.camera);
					if (nodeGuideManager.closestGuideX && nodeGuideManager.closestGuideY)	{
						nodeManager.AddNode(Vector2{nodeGuideManager.closestGuideX->position.x, nodeGuideManager.closestGuideY->position.y});
					}
					else if (nodeGuideManager.closestGuideX || nodeGuideManager.closestGuideY){
						distanceInputWindow.showDistanceWindow = true;
						distanceInputWindow.screenPosition = mousePosition;
						distanceInputWindow.clickWorldPosition = GetScreenToWorld2D(mousePosition, cameraController.camera);

						if (nodeGuideManager.closestGuideX)	{
							distanceInputWindow.isX = true;
							distanceInputWindow.nodeWorldPosition = nodeGuideManager.closestGuideX->position;
						} else {
							distanceInputWindow.isX = false;
							distanceInputWindow.nodeWorldPosition = nodeGuideManager.closestGuideY->position;
						}
					} else {
						if (showGrid) {
							nodeManager.AddNode(worldGridPosition);
						} else {
							nodeManager.AddNode(worldPosition);
						}
					}
				}
				break;

			case ToolMode::NodeRem:
				if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
					for (auto &node : nodeManager.nodes){
						if (node->IsNearby(GetScreenToWorld2D(mousePosition, cameraController.camera), raioNo, cameraController.camera.zoom)){
							nodesToRemove.push_back(node);
						}
					}
				}
				beamManager.RemoveBeamsConnectedToNodes(nodesToRemove);
				nodeManager.RemoveNode(nodesToRemove);

				nodesToRemove.clear();
				break;
			case ToolMode::BeamAdd:
				closestNode = nodeManager.FindClosestNode(worldPosition, cameraController.camera);
				drawCursorOnClosestNode = true;	

				if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT))	{	
					if (beamStart == nullptr) {
    				    closestNode = nodeManager.FindClosestNode(worldPosition, cameraController.camera);
    				    if (closestNode != nullptr) {
    				        beamStart = closestNode;
    				        std::cout << "Nó inicial anotado" << std::endl;
    				    }
    				} else if (beamEnd == nullptr) {
    				    closestNode = nodeManager.FindClosestNode(worldPosition, cameraController.camera);
    				    if (closestNode != nullptr && closestNode != beamStart) {
    				        beamEnd = closestNode;
    				        std::cout << "Nó final anotado e criando barra" << std::endl;
    				        beamManager.AddBeam(beamStart, beamEnd);
    				        beamStart = nullptr;
    				        beamEnd = nullptr;
    				    }
    			}
				
				break;
				
			default:
		        std::cout << "Modo desconhecido" << std::endl;
		        break;
			}
		}

							


		



		
		
		
		
		
		nodeGuideManager.UpdateGuides(&nodeManager.nodes, GetScreenToWorld2D(GetMousePosition(), cameraController.camera), cameraController.camera);
		
		std::ostringstream positionStream;
		positionStream << "Pos: (" << std::fixed << std::setprecision(3) << worldGridPosition.x << ", " << worldGridPosition.y << ")";
    	positionText = positionStream.str();
	}
	template <class Archive>
    void serialize(Archive& ar) {
        ar(
            cereal::make_nvp("cameraController", cameraController),
            cereal::make_nvp("nodes", nodeManager),
            cereal::make_nvp("beams", beamManager)
        );
    }
};


void saveEditor(const EditorWindow& editor, const std::string& filename) {
    std::ofstream os(filename);
    cereal::JSONOutputArchive archive(os);
    archive(cereal::make_nvp("editor", editor));
}

void loadEditor(EditorWindow& editor, const std::string& filename) {
    std::ifstream is(filename);
    if (!is.is_open()) {
        std::cerr << "Failed to open " << filename << std::endl;
        return;  // Este return está aqui apenas para sair da função caso o arquivo não possa ser aberto
    }
    cereal::JSONInputArchive archive(is);
    archive(cereal::make_nvp("editor", editor));
}


EditorWindow editor;

void DoMainMenu()
{
	if (ImGui::BeginMainMenuBar())
	{
		if (ImGui::BeginMenu("Arquivo"))
		{
			if (ImGui::MenuItem("Salvar")) {
                saveEditor(editor, "editor.json");
            }
            if (ImGui::MenuItem("Carregar")) {
                loadEditor(editor, "editor.json");
            }
			if (ImGui::MenuItem("Sair"))
				Quit = true;

			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu("Janela"))
		{
			ImGui::MenuItem("ImGui Demo", nullptr, &ImGuiDemoOpen);


			ImGui::EndMenu();
		}
		ImGui::EndMainMenuBar();
	}
}



int main(int argc, char* argv[])
{
	// Initialization
	//--------------------------------------------------------------------------------------
	int screenWidth = 1900;
	int screenHeight = 900;

	
	

	SetConfigFlags(FLAG_MSAA_4X_HINT | FLAG_WINDOW_RESIZABLE);
	InitWindow(screenWidth, screenHeight, "Ftool Knockoff");
	SetExitKey(KEY_NULL);
	SetTargetFPS(244);
	rlImGuiBeginInitImGui();
    ImGui::StyleColorsLight();

    ImFont* font = ImGui::GetIO().Fonts->AddFontFromFileTTF("resources/segoeuisl.ttf", 18);

    rlImGuiEndInitImGui();

	ImGui::GetIO().ConfigWindowsMoveFromTitleBarOnly = true;


	topMenu.Setup();
	topMenu.Open = true;
	toolsMenu.Setup();
	toolsMenu.Open = true;
	editor.Setup();
	editor.Open = true;

	// Main game loop
	while (!WindowShouldClose() && !Quit)    // Detect window close button or ESC key
	{
		BeginDrawing();
		ClearBackground(DARKGRAY);
		DrawFPS(leftMenuSize, topPadding);
		
		/*════════════════════════ UPDATE ════════════════════════*/
		topMenu.Update();
		toolsMenu.Update();
		if (!editor.distanceInputWindow.showDistanceWindow)
			editor.Update();
		



		/*═════════════════════════ DRAW ═════════════════════════*/
		if (editor.Open)
			editor.Show();
		rlImGuiBegin();
		ImGui::PushFont(font);
		DoMainMenu();

		if (ImGuiDemoOpen)
			ImGui::ShowDemoWindow(&ImGuiDemoOpen);


		if (toolsMenu.Open)
			toolsMenu.Show();
		if (topMenu.Open)
			topMenu.Show();

		editor.distanceInputWindow.draw();
		/*════════════════════════════════════════════════════════*/

		ImGui::PopFont();
		rlImGuiEnd();

		EndDrawing();
	}
	rlImGuiShutdown();

	toolsMenu.Shutdown();
	editor.Shutdown();

	// De-Initialization
	//--------------------------------------------------------------------------------------   
	CloseWindow();        // Close window and OpenGL context
	//--------------------------------------------------------------------------------------

	return 0;
}